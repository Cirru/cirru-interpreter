// Generated by CoffeeScript 1.6.3
var error, log_error, main, print, stringify, type,
  __slice = [].slice;

error = require('cirru-parser').error;

main = require('./main');

exports.type = type = function(x) {
  return Object.prototype.toString.call(x).slice(1, -1).split(' ')[1].toLowerCase();
};

exports.stringify = stringify = function(object) {
  return JSON.stringify(object, null, 2);
};

exports.print = print = function() {
  var xs;
  xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return console.log.apply(console, xs);
};

exports.log_error = log_error = function(token, message) {
  var options;
  options = {
    text: message,
    x: token.x,
    y: token.y,
    file: token.file
  };
  return print(error(options));
};

exports.prelude = {
  number: function(scope, list) {
    var number, x;
    if (list[1] == null) {
      log_error(list[0], 'need number here');
    }
    x = list[1];
    number = parseInt(x.text);
    if (isNaN(number)) {
      return log_error(x, "" + (stringify(x.text)) + " is not valid number");
    } else {
      return number;
    }
  },
  bool: function(scope, list) {
    var x, _ref, _ref1;
    if (list[1] == null) {
      log_error(list[0], 'need bool symbol here');
    }
    x = list[1];
    if ((_ref = x.text) === 'yes' || _ref === 'true' || _ref === 'on' || _ref === 'ok' || _ref === 'right') {
      return true;
    } else if ((_ref1 = x.text) === 'no' || _ref1 === 'false' || _ref1 === 'off' || _ref1 === 'wrong') {
      return false;
    } else {
      return log_error(x, "" + (stringify(x.text)) + " is not a valid bool");
    }
  },
  string: function(scope, list) {
    var x;
    if (list[1] == null) {
      log_error(list[0], 'need string here');
    }
    x = list[1];
    return list[1].text;
  },
  array: function(scope, list) {
    return list.slice(1).map(function(x) {
      var the_type;
      the_type = type(x);
      if (the_type === 'object') {
        return x;
      } else if (the_type === 'array') {
        return main.interpret(scope, x);
      } else {
        return log_error(x, "" + (stringify(x.text)) + " is not a valid list item");
      }
    });
  },
  hash: function(scope, list) {
    var object;
    object = {};
    list.slice(1).map(function(pair) {
      return object[pair[0]] = main.interpret(scope, pair[1]);
    });
    return object;
  },
  regex: function(scope, list) {
    if (list[1] == null) {
      log_error(list[0], 'need regular expression');
    }
    if (list[2] != null) {
      return new RegExp(list[1], list[2]);
    } else {
      return new RegExp(list[1]);
    }
  },
  set: function(scope, list) {
    var the_type;
    if (!((list[1] != null) && (list[2] != null))) {
      log_error(list[0], 'set need 2 arguments');
    }
    if ((type(list[2])) !== 'array') {
      log_error(list[2], 'this should be an expression');
    }
    the_type = type(list[1]);
    if (the_type === 'object') {
      return scope[list[1].text] = main.interpret(scope, list[2]);
    } else if (the_type === 'array') {
      return scope[main.interpret(scope, list[1])] = main.interpret(scope, list[2]);
    }
  },
  get: function(scope, list) {
    var the_type;
    if (list[1] == null) {
      log_error(list[0], 'add your variable to get');
    }
    the_type = type(list[1]);
    if (the_type === 'object') {
      return scope[list[1].text];
    } else if (the_type === 'array') {
      return scope[main.interpret(scope, list[1])];
    }
  },
  print: function(scope, list) {
    var the_type;
    if (list[1] == null) {
      log_error(list[0], 'write something you want to print');
    }
    the_type = type(list[1]);
    if (the_type === 'object') {
      return print(list[1].text);
    } else if (the_type === 'array') {
      return print(main.interpret(scope, list[1]));
    }
  },
  'get-scope': function(scope, list) {
    return scope;
  },
  'load-scope': function(scope, list) {
    var child;
    if (!((list[1] != null) && (list[2] != null))) {
      log_error(list[0], 'need at less 2 arguments..');
    }
    if ((type(list[1])) !== 'object') {
      log_error(list[1], 'should be a variable name');
    }
    if ((type(list[2])) !== 'array') {
      log_error(list[2], 'supposed to be expression here');
    }
    child = scope[list[1].text];
    if ((type(child)) !== 'object') {
      log_error(list[1], 'not referring to object');
    }
    return list.slice(2).map(function(expression) {
      return main.interpret(child, expression);
    });
  }
};
