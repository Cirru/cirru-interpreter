// Generated by CoffeeScript 1.6.3
var EventEmitter, assert, be_type, cirru_error, cirru_read, error, fs, has_no_undefined, length_equal, longer_than, main, ms, parse, path, print, reload_scope, reloading, stringify, type, util, watch_scope, _ref, _ref1;

path = require('path');

fs = require('fs');

util = require('util');

EventEmitter = require('events').EventEmitter;

_ref = require('cirru-parser'), error = _ref.error, parse = _ref.parse;

main = require('./main');

_ref1 = require('./tool'), type = _ref1.type, print = _ref1.print, stringify = _ref1.stringify, assert = _ref1.assert;

exports.cirru_error = cirru_error = function(token, message) {
  var options;
  options = {
    text: message,
    x: token.x,
    y: token.y,
    file: token.file
  };
  util.print(error(options));
  throw new Error(message);
};

cirru_read = function(scope, xs) {
  return xs.map(function(x) {
    var ret;
    if ((type(x)) === 'object') {
      ret = scope[x.text];
      if (ret == null) {
        cirru_error(x, "missing: " + x.text);
      }
      return ret;
    } else if ((type(x)) === 'array') {
      return main.interpret(scope, x);
    } else {
      return cirru_error(x, "cannot recognize " + (stringify(x)));
    }
  });
};

has_no_undefined = function(args) {
  return args.map(function(x) {
    return assert(x !== void 0, 'undefined not allowed');
  });
};

longer_than = function(args, length) {
  return assert(args.length > length, "args should be longer then " + length);
};

length_equal = function(args, length) {
  return assert(args.length === length, "length of args should be " + length);
};

be_type = function(x, a_type) {
  return assert((type(x)) === a_type, "" + x + " here should be a " + a_type);
};

exports.prelude = {
  number: function(scope, list) {
    var args, number, x;
    args = list.slice(1);
    length_equal(args, 1);
    x = args[0];
    be_type(x.text, 'string');
    number = parseInt(x.text);
    if (isNaN(number)) {
      return cirru_error(x, "" + (stringify(x.text)) + " is not valid number");
    } else {
      return number;
    }
  },
  bool: function(scope, list) {
    var args, x, _ref2, _ref3;
    args = list.slice(1);
    length_equal(args, 1);
    x = args[0];
    if ((_ref2 = x.text) === 'yes' || _ref2 === 'true' || _ref2 === 'on' || _ref2 === 'ok' || _ref2 === 'right') {
      return true;
    } else if ((_ref3 = x.text) === 'no' || _ref3 === 'false' || _ref3 === 'off' || _ref3 === 'wrong') {
      return false;
    } else {
      return cirru_error(x, "" + (stringify(x.text)) + " is not a valid bool");
    }
  },
  string: function(scope, list) {
    var args;
    args = list.slice(1);
    length_equal(args, 1);
    return args[0].text;
  },
  array: function(scope, list) {
    var args;
    args = cirru_read(scope, list.slice(1));
    return args;
  },
  hash: function(scope, list) {
    var args, object;
    args = list.slice(1);
    object = {};
    args.map(function(pair) {
      return object[pair[0].text] = main.interpret(scope, pair[1]);
    });
    return object;
  },
  regex: function(scope, list) {
    var args;
    args = list.slice(1);
    length_equal(args, 1);
    if (typeof x !== "undefined" && x !== null) {
      return new RegExp(list[1], list[2]);
    } else {
      return new RegExp(list[1]);
    }
  },
  set: function(scope, list) {
    var args, key, the_type, value;
    args = list.slice(1);
    has_no_undefined(args);
    be_type(args[1], 'array');
    the_type = type(list[1]);
    value = main.interpret(scope, args[1]);
    key = the_type === 'object' ? args[0].text : the_type === 'array' ? main.interpret(scope, list[1]) : void 0;
    return scope[key] = value;
  },
  get: function(scope, list) {
    var args, the_type;
    args = list.slice(1);
    has_no_undefined(args);
    the_type = type(args[0]);
    if (the_type === 'object') {
      return scope[list[1].text];
    } else if (the_type === 'array') {
      return scope[main.interpret(scope, list[1])];
    }
  },
  print: function(scope, list) {
    var args;
    args = list.slice(1).map(function(x) {
      var ret;
      if ((type(x.text)) === 'string') {
        return scope[x];
      } else if ((type(x)) === 'array') {
        ret = main.interpret(scope, x);
        return ret;
      }
    });
    has_no_undefined(args);
    longer_than(args, 0);
    return print.apply(null, args);
  },
  echo: function(scope, list) {
    var args;
    args = cirru_read(scope, list.slice(1));
    has_no_undefined(args);
    longer_than(args, 0);
    return print.apply(null, args);
  },
  'get-scope': function(scope, list) {
    return scope;
  },
  'load-scope': function(scope, list) {
    var args, child, x;
    args = list.slice(1);
    has_no_undefined(args);
    longer_than(args, 1);
    x = args[0];
    if ((type(x)) === 'object') {
      child = scope[x.text];
    } else if ((type(x)) === 'array') {
      child = main.interpret(scope, x);
    } else {
      cirru_error(list[1], 'should be a link to a scope');
    }
    be_type(child, 'object');
    return args.slice(1).map(function(expression) {
      assert(expression, 'supposed to be expression here');
      return main.interpret(child, expression);
    });
  },
  under: function(scope, list) {
    var args, child, parent;
    args = list.slice(1);
    longer_than(args, 2);
    has_no_undefined(args);
    if ((type(list[1])) === 'object') {
      parent = scope[list[1].text];
    } else if ((type(list[1])) === 'array') {
      parent = main.interpret(scope, list[1]);
    } else {
      cirru_error(list[1], 'should be a variable name');
    }
    if ((type(list[2])) !== 'array') {
      cirru_error(list[2], 'supposed to be expression here');
    }
    child = {
      __proto__: parent,
      parent: scope
    };
    if ((type(child)) !== 'object') {
      cirru_error(list[1], 'not referring to object');
    }
    return list.slice(2).map(function(expression) {
      return main.interpret(child, expression);
    });
  },
  code: function(scope, list) {
    var args;
    args = list.slice(1);
    has_no_undefined(args);
    longer_than(args, 0);
    args.map(function(expression) {
      return be_type(expression, 'array');
    });
    return {
      parent: scope,
      list: args
    };
  },
  "eval": function(scope, list) {
    var args, child, code;
    args = list.slice(1);
    has_no_undefined(args);
    longer_than(args, 0);
    args.map(function(expression) {
      return be_type(expression, 'array');
    });
    code = main.interpret(scope, list[1]);
    child = {
      parent: code.parent,
      outer: scope
    };
    return code.list.map(function(expression) {
      return main.interpret(child, expression);
    });
  },
  assert: function(scope, list) {
    var args, note, value;
    args = list.slice(1);
    has_no_undefined(args);
    length_equal(args, 2);
    value = main.interpret(scope, args[0]);
    note = main.interpret(scope, args[1]);
    if (value === false) {
      print(note);
      return assert(false, "assert " + list[1] + " equals " + list[2] + " failed");
    }
  },
  comment: function(scope, list) {},
  equal: function(scope, list) {
    var args;
    args = cirru_read(scope, list.slice(1));
    has_no_undefined(args);
    length_equal(args, 2);
    return args[0] === args[1];
  },
  require: function(scope, list) {
    var args, module_path, x;
    args = list.slice(1);
    has_no_undefined(args);
    x = args[0];
    module_path = path.join(x.file.path, '../', x.text);
    assert(fs.existsSync(module_path), "no module named " + module_path);
    if (ms[module_path] == null) {
      ms[module_path] = {};
      ms[module_path] = main.run(scope, parse(module_path));
      watch_scope(module_path);
    }
    return ms[module_path].exports;
  },
  add: function(scope, list) {
    var args;
    args = cirru_read(scope, list.slice(1));
    has_no_undefined(args);
    longer_than(args, 1);
    args.map(function(x) {
      return be_type(x, 'number');
    });
    return args.reduce((function(x, y) {
      return x + y;
    }), 0);
  }
};

ms = {};

reload_scope = function() {
  Object.keys(ms).map(function(module_path) {
    return fs.unwatchFile(module_path);
  });
  return ms = {};
};

exports.reloading = reloading = new EventEmitter;

watch_scope = function(module_path) {
  return fs.watchFile(module_path, {
    interval: 200
  }, function() {
    console.log('reloading......');
    reload_scope();
    return reloading.emit('reload');
  });
};

/*
//@ sourceMappingURL=prelude.map
*/
