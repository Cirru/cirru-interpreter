// Generated by CoffeeScript 1.6.3
var error, fs, log_error, main, parse, path, print, stringify, type, _ref, _ref1;

path = require('path');

fs = require('fs');

_ref = require('cirru-parser'), error = _ref.error, parse = _ref.parse;

main = require('./main');

_ref1 = require('./tool'), type = _ref1.type, print = _ref1.print, stringify = _ref1.stringify;

exports.log_error = log_error = function(token, message) {
  var options;
  options = {
    text: message,
    x: token.x,
    y: token.y,
    file: token.file
  };
  print(error(options));
  throw new Error('out from log error');
};

exports.prelude = {
  number: function(scope, list) {
    var number, x;
    if (list[1] == null) {
      log_error(list[0], 'need number here');
    }
    x = list[1];
    number = parseInt(x.text);
    if (isNaN(number)) {
      return log_error(x, "" + (stringify(x.text)) + " is not valid number");
    } else {
      return number;
    }
  },
  bool: function(scope, list) {
    var x, _ref2, _ref3;
    if (list[1] == null) {
      log_error(list[0], 'need bool symbol here');
    }
    x = list[1];
    if ((_ref2 = x.text) === 'yes' || _ref2 === 'true' || _ref2 === 'on' || _ref2 === 'ok' || _ref2 === 'right') {
      return true;
    } else if ((_ref3 = x.text) === 'no' || _ref3 === 'false' || _ref3 === 'off' || _ref3 === 'wrong') {
      return false;
    } else {
      return log_error(x, "" + (stringify(x.text)) + " is not a valid bool");
    }
  },
  string: function(scope, list) {
    var x;
    if (list[1] == null) {
      log_error(list[0], 'need string here');
    }
    x = list[1];
    return list[1].text;
  },
  array: function(scope, list) {
    return list.slice(1).map(function(x) {
      var the_type;
      the_type = type(x);
      if (the_type === 'object') {
        return x;
      } else if (the_type === 'array') {
        return main.interpret(scope, x);
      } else {
        return log_error(x, "" + (stringify(x.text)) + " is not a valid list item");
      }
    });
  },
  hash: function(scope, list) {
    var object;
    object = {};
    list.slice(1).map(function(pair) {
      return object[pair[0].text] = main.interpret(scope, pair[1]);
    });
    return object;
  },
  regex: function(scope, list) {
    if (list[1] == null) {
      log_error(list[0], 'need regular expression');
    }
    if (list[2] != null) {
      return new RegExp(list[1], list[2]);
    } else {
      return new RegExp(list[1]);
    }
  },
  set: function(scope, list) {
    var the_type;
    if (!((list[1] != null) && (list[2] != null))) {
      log_error(list[0], 'set need 2 arguments');
    }
    if ((type(list[2])) !== 'array') {
      log_error(list[2], 'this should be an expression');
    }
    the_type = type(list[1]);
    if (the_type === 'object') {
      return scope[list[1].text] = main.interpret(scope, list[2]);
    } else if (the_type === 'array') {
      return scope[main.interpret(scope, list[1])] = main.interpret(scope, list[2]);
    }
  },
  get: function(scope, list) {
    var the_type;
    if (list[1] == null) {
      log_error(list[0], 'add your variable to get');
    }
    the_type = type(list[1]);
    if (the_type === 'object') {
      return scope[list[1].text];
    } else if (the_type === 'array') {
      return scope[main.interpret(scope, list[1])];
    }
  },
  print: function(scope, list) {
    var the_type;
    if (list[1] == null) {
      log_error(list[0], 'write something you want to print');
    }
    the_type = type(list[1]);
    if (the_type === 'object') {
      return print(list[1].text);
    } else if (the_type === 'array') {
      return print(main.interpret(scope, list[1]));
    }
  },
  'get-scope': function(scope, list) {
    return scope;
  },
  'load-scope': function(scope, list) {
    var child;
    if (!((list[1] != null) && (list[2] != null))) {
      log_error(list[0], 'need at less 2 arguments..');
    }
    if ((type(list[1])) === 'object') {
      child = scope[list[1].text];
    } else if ((type(list[1])) === 'array') {
      child = main.interpret(scope, list[1]);
    } else {
      log_error(list[1], 'should be a variable name');
    }
    if ((type(list[2])) !== 'array') {
      log_error(list[2], 'supposed to be expression here');
    }
    if ((type(child)) !== 'object') {
      log_error(list[1], 'not referring to object');
    }
    return list.slice(2).map(function(expression) {
      return main.interpret(child, expression);
    });
  },
  under: function(scope, list) {
    var child, parent;
    if (!((list[1] != null) && (list[2] != null))) {
      log_error(list[0], 'need at less 2 arguments..');
    }
    if ((type(list[1])) === 'object') {
      parent = scope[list[1].text];
    } else if ((type(list[1])) === 'array') {
      parent = main.interpret(scope, list[1]);
    } else {
      log_error(list[1], 'should be a variable name');
    }
    if ((type(list[2])) !== 'array') {
      log_error(list[2], 'supposed to be expression here');
    }
    child = {
      __proto__: parent,
      parent: scope
    };
    if ((type(child)) !== 'object') {
      log_error(list[1], 'not referring to object');
    }
    return list.slice(2).map(function(expression) {
      return main.interpret(child, expression);
    });
  },
  code: function(scope, list) {
    if (list[1] == null) {
      log_error(list[0], 'add some code here');
    }
    list.slice(1).map(function(expression) {
      if ((type(expression)) !== 'array') {
        return log_error(list[1], 'use expression');
      }
    });
    return {
      parent: scope,
      list: list.slice(1)
    };
  },
  "eval": function(scope, list) {
    var child, code;
    if (list[1] == null) {
      log_error(list[0], 'find code to eval');
    }
    if ((type(list[1])) !== 'array') {
      log_error(list[1], 'should be expression here');
    }
    code = main.interpret(scope, list[1]);
    child = {
      parent: code.parent,
      outer: scope
    };
    return code.list.map(function(expression) {
      return main.interpret(child, expression);
    });
  },
  "import": function(scope, list) {
    var module_path;
    if (list[1] == null) {
      log_error(list[0], 'add path to be imported');
    }
    if ((type(list[1])) !== 'object') {
      log_error(list[0], 'need argument in string');
    }
    module_path = path.join(list[1].file.path, '..', list[1].text);
    if (!fs.existsSync(module_path)) {
      log_error(list[1], "no file named " + module_path);
    }
    return main.run(scope, parse(module_path));
  }
};
