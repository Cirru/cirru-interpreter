// Generated by CoffeeScript 1.6.3
var EventEmitter, a_token, an_expression, assert, be_type, check_numbers, cirru_error, cirru_read, error, fs, has_no_undefined, length_equal, longer_than, main, ms, parse, path, print, reload_scope, reloading, stringify, type, util, watch_scope, _ref, _ref1;

path = require('path');

fs = require('fs');

util = require('util');

EventEmitter = require('events').EventEmitter;

_ref = require('cirru-parser'), error = _ref.error, parse = _ref.parse;

main = require('./main');

_ref1 = require('./tool'), type = _ref1.type, print = _ref1.print, stringify = _ref1.stringify, assert = _ref1.assert;

exports.cirru_error = cirru_error = function(token, message) {
  var options;
  options = {
    text: message,
    x: token.x,
    y: token.y,
    file: token.file
  };
  util.print(error(options));
  throw new Error(message);
};

cirru_read = function(scope, xs) {
  return xs.map(function(x) {
    var ret;
    if ((type(x)) === 'object') {
      ret = scope[x.text];
      if (ret == null) {
        cirru_error(x, "missing: " + x.text);
      }
      return ret;
    } else if ((type(x)) === 'array') {
      return main.interpret(scope, x);
    } else {
      return cirru_error(x, "cannot recognize " + (stringify(x)));
    }
  });
};

has_no_undefined = function(args) {
  return args.map(function(x) {
    return assert(x !== void 0, 'undefined not allowed');
  });
};

longer_than = function(args, length) {
  return assert(args.length > length, "args should be longer then " + length);
};

length_equal = function(args, length) {
  return assert(args.length === length, "length of args should be " + length);
};

be_type = function(x, a_type) {
  return assert((type(x)) === a_type, "" + x + " here should be a " + a_type);
};

check_numbers = function(scope, list) {
  var args;
  args = cirru_read(scope, list.slice(1));
  has_no_undefined(args);
  args.map(function(x) {
    return be_type(x, 'number');
  });
  return args;
};

a_token = function(x) {
  return (x != null) && (type(x.text)) === 'string';
};

an_expression = function(xs) {
  return (type(xs)) === 'array' && xs.length > 0;
};

exports.prelude = {
  number: function(scope, list) {
    var args, number, x;
    args = list.slice(1);
    length_equal(args, 1);
    x = args[0];
    be_type(x.text, 'string');
    number = Number(x.text);
    if (isNaN(number)) {
      return cirru_error(x, "" + (stringify(x.text)) + " is not valid number");
    } else {
      return number;
    }
  },
  bool: function(scope, list) {
    var args, x, _ref2, _ref3;
    args = list.slice(1);
    length_equal(args, 1);
    x = args[0];
    if ((_ref2 = x.text) === 'yes' || _ref2 === 'true' || _ref2 === 'on' || _ref2 === 'ok' || _ref2 === 'right') {
      return true;
    } else if ((_ref3 = x.text) === 'no' || _ref3 === 'false' || _ref3 === 'off' || _ref3 === 'wrong') {
      return false;
    } else if ((0 < x && x < Infinity)) {
      return true;
    } else if ((-Infinity < x && x < 0)) {
      return false;
    } else {
      return cirru_error(x, "" + (stringify(x.text)) + " is not a valid bool");
    }
  },
  string: function(scope, list) {
    var args, x;
    args = list.slice(1);
    length_equal(args, 1);
    x = args[0];
    if ((type(x.text)) === 'string') {
      return x.text;
    } else if ((type(x)) === 'array') {
      return String(main.interpret(scope, x));
    } else {
      return cirru_error(x, "" + x + " is not a string");
    }
  },
  array: function(scope, list) {
    var args;
    args = cirru_read(scope, list.slice(1));
    has_no_undefined(args);
    return args;
  },
  hash: function(scope, list) {
    var args, object;
    args = list.slice(1);
    has_no_undefined(args);
    object = {};
    args.map(function(pair) {
      return object[pair[0].text] = main.interpret(scope, pair[1]);
    });
    return object;
  },
  regex: function(scope, list) {
    var args;
    args = list.slice(1);
    length_equal(args, 1);
    if (typeof x !== "undefined" && x !== null) {
      return new RegExp(args[0], args[1]);
    } else {
      return new RegExp(args[0]);
    }
  },
  nil: function(scope, list) {
    return null;
  },
  at: function(scope, list) {
    var args, key, ret, x;
    args = list.slice(1);
    has_no_undefined(args);
    length_equal(args, 2);
    x = args[0];
    key = args[1];
    if (an_expression(x)) {
      x = main.interpret(scope, x);
    } else if (a_token(x)) {
      x = scope[x.text];
    }
    if (an_expression(key)) {
      key = main.interpret(scope, key);
    } else if (a_token(key)) {
      key = key.x;
    }
    if ((type(x)) === 'number') {
      x += 1;
    }
    ret = x[key];
    assert(ret !== void 0, "" + x + "[" + key + "] got undefined");
    return ret;
  },
  set: function(scope, list) {
    var args, key, the_type, value;
    args = list.slice(1);
    has_no_undefined(args);
    be_type(args[1], 'array');
    the_type = type(args[0]);
    value = main.interpret(scope, args[1]);
    key = the_type === 'object' ? args[0].text : the_type === 'array' ? main.interpret(scope, args[0]) : void 0;
    return scope[key] = value;
  },
  get: function(scope, list) {
    var args, the_type;
    args = list.slice(1);
    has_no_undefined(args);
    the_type = type(args[0]);
    if (the_type === 'object') {
      return scope[args[0].text];
    } else if (the_type === 'array') {
      return scope[main.interpret(scope, args[0])];
    }
  },
  print: function(scope, list) {
    var args, ret;
    ret = null;
    args = list.slice(1).map(function(x) {
      if ((type(x.text)) === 'string') {
        return scope[x.text];
      } else if ((type(x)) === 'array') {
        return main.interpret(scope, x);
      } else {
        return cirru_error(x, 'unexpected case');
      }
    });
    has_no_undefined(args);
    longer_than(args, 0);
    args = args.map(function(x) {
      if (x != null) {
        return x;
      } else {
        return 'nil';
      }
    });
    print.apply(null, args);
    return ret;
  },
  echo: function(scope, list) {
    var args;
    args = list.slice(1);
    args.map(function(x) {
      return be_type(x.text, 'string');
    });
    longer_than(args, 0);
    return print(args.map(function(x) {
      return x.text;
    }).join(' '));
  },
  'get-scope': function(scope, list) {
    return scope;
  },
  'load-scope': function(scope, list) {
    var args, child, x;
    args = list.slice(1);
    has_no_undefined(args);
    longer_than(args, 1);
    x = args[0];
    if ((type(x)) === 'object') {
      child = scope[x.text];
    } else if ((type(x)) === 'array') {
      child = main.interpret(scope, x);
    } else {
      cirru_error(args[0], 'should be a link to a scope');
    }
    be_type(child, 'object');
    return args.slice(1).map(function(expression) {
      assert(expression, 'supposed to be expression here');
      return main.interpret(child, expression);
    });
  },
  under: function(scope, list) {
    var args, child, parent;
    args = list.slice(1);
    longer_than(args, 2);
    has_no_undefined(args);
    if ((type(args[0])) === 'object') {
      parent = scope[args[0].text];
    } else if ((type(args[0])) === 'array') {
      parent = main.interpret(scope, args[0]);
    } else {
      cirru_error(args[0], 'should be a variable name');
    }
    if ((type(args[1])) !== 'array') {
      cirru_error(args[1], 'supposed to be expression here');
    }
    child = {
      __proto__: parent,
      parent: scope
    };
    if ((type(child)) !== 'object') {
      cirru_error(args[0], 'not referring to object');
    }
    return list.slice(2).map(function(expression) {
      return main.interpret(child, expression);
    });
  },
  code: function(scope, list) {
    var args;
    args = list.slice(1);
    has_no_undefined(args);
    longer_than(args, 0);
    args.map(function(expression) {
      return be_type(expression, 'array');
    });
    return {
      parent: scope,
      ast: args
    };
  },
  "eval": function(scope, list) {
    var args, child, code, ret;
    args = list.slice(1);
    has_no_undefined(args);
    longer_than(args, 0);
    args.map(function(expression) {
      return be_type(expression, 'array');
    });
    code = main.interpret(scope, args[0]);
    child = {
      parent: code.parent,
      outer: scope
    };
    ret = false;
    code.ast.map(function(expression) {
      return ret = main.interpret(child, expression);
    });
    return ret;
  },
  assert: function(scope, list) {
    var args, note, value;
    args = list.slice(1);
    has_no_undefined(args);
    length_equal(args, 2);
    value = main.interpret(scope, args[0]);
    note = main.interpret(scope, args[1]);
    if (value === false) {
      print(note);
      return assert(false, "assert " + args[0] + " equals " + args[1] + " failed");
    }
  },
  comment: function(scope, list) {},
  equal: function(scope, list) {
    var args;
    args = cirru_read(scope, list.slice(1));
    has_no_undefined(args);
    length_equal(args, 2);
    return args[0] === args[1];
  },
  require: function(scope, list) {
    var args, module_path, x;
    args = list.slice(1);
    has_no_undefined(args);
    x = args[0];
    module_path = path.join(x.file.path, '../', x.text);
    assert(fs.existsSync(module_path), "no module named " + module_path);
    if (ms[module_path] == null) {
      ms[module_path] = {};
      ms[module_path] = main.run(scope, parse(module_path));
      watch_scope(module_path);
    }
    return ms[module_path].exports;
  },
  add: function(scope, list) {
    var args;
    args = check_numbers(scope, list);
    longer_than(args, 1);
    return args.reduce((function(x, y) {
      return x + y;
    }), 0);
  },
  minus: function(scope, list) {
    var args;
    args = check_numbers(scope, list);
    longer_than(args, 1);
    return args.reduce((function(x, y) {
      return x - y;
    }), 0);
  },
  multiply: function(scope, list) {
    var args;
    args = check_numbers(scope, list);
    longer_than(args, 1);
    return args.reduce((function(x, y) {
      return x * y;
    }), 0);
  },
  divide: function(scope, list) {
    var args;
    args = check_numbers(scope, list);
    longer_than(args, 1);
    return args.reduce((function(x, y) {
      return x / y;
    }), 0);
  },
  round: function(scope, list) {
    var args, x;
    args = check_numbers(scope, list);
    x = args[0];
    return Math.round(x);
  },
  floor: function(scope, list) {
    var args, x;
    args = check_numbers(scope, list);
    x = args[0];
    return Math.floor(x);
  },
  "if": function(scope, list) {
    var args, condition, x;
    args = list.slice(1);
    x = args[0];
    an_expression(x);
    args.map(an_expression);
    longer_than(args, 1);
    condition = main.interpret(scope, x);
    if (condition) {
      return main.interpret(scope, args[1]);
    } else if (args[2] != null) {
      return main.interpret(scope, args[2]);
    }
  },
  begin: function(scope, list) {
    var args, ret;
    args = list.slice(1);
    args.map(an_expression);
    ret = null;
    args.map(function(x) {
      return ret = main.interpret(scope, x);
    });
    return ret;
  }
};

ms = {};

reload_scope = function() {
  Object.keys(ms).map(function(module_path) {
    return fs.unwatchFile(module_path);
  });
  return ms = {};
};

exports.reloading = reloading = new EventEmitter;

reloading.on('reload', function() {
  return reload_scope();
});

watch_scope = function(module_path) {
  return fs.watchFile(module_path, {
    interval: 200
  }, function() {
    return reloading.emit('reload', module_path);
  });
};

/*
//@ sourceMappingURL=prelude.map
*/
